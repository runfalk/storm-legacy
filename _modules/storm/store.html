
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>storm.store &#8212; Storm  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for storm.store</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (c) 2006, 2007 Canonical</span>
<span class="c1">#</span>
<span class="c1"># Written by Gustavo Niemeyer &lt;gustavo@niemeyer.net&gt;</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Storm Object Relational Mapper.</span>
<span class="c1">#</span>
<span class="c1"># Storm is free software; you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License as</span>
<span class="c1"># published by the Free Software Foundation; either version 2.1 of</span>
<span class="c1"># the License, or (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># Storm is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU Lesser General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;The Store interface to a database.</span>

<span class="sd">This module contains the highest-level ORM interface in Storm.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="k">import</span> <span class="n">WeakValueDictionary</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>

<span class="kn">from</span> <span class="nn">storm.compat</span> <span class="k">import</span> <span class="n">iter_items</span><span class="p">,</span> <span class="n">iter_values</span><span class="p">,</span> <span class="n">iter_zip</span><span class="p">,</span> <span class="n">long_int</span>
<span class="kn">from</span> <span class="nn">storm.info</span> <span class="k">import</span> <span class="n">get_cls_info</span><span class="p">,</span> <span class="n">get_obj_info</span><span class="p">,</span> <span class="n">set_obj_info</span>
<span class="kn">from</span> <span class="nn">storm.variables</span> <span class="k">import</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">LazyValue</span>
<span class="kn">from</span> <span class="nn">storm.expr</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Expr</span><span class="p">,</span> <span class="n">Select</span><span class="p">,</span> <span class="n">Insert</span><span class="p">,</span> <span class="n">Update</span><span class="p">,</span> <span class="n">Delete</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Count</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span>
    <span class="n">Avg</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Asc</span><span class="p">,</span> <span class="n">Desc</span><span class="p">,</span> <span class="n">compile_python</span><span class="p">,</span> <span class="n">compare_columns</span><span class="p">,</span> <span class="n">SQLRaw</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span> <span class="n">Except</span><span class="p">,</span> <span class="n">Intersect</span><span class="p">,</span> <span class="n">Alias</span><span class="p">,</span> <span class="n">SetExpr</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">storm.exceptions</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">WrongStoreError</span><span class="p">,</span> <span class="n">NotFlushedError</span><span class="p">,</span> <span class="n">OrderLoopError</span><span class="p">,</span> <span class="n">UnorderedError</span><span class="p">,</span>
    <span class="n">NotOneError</span><span class="p">,</span> <span class="n">FeatureError</span><span class="p">,</span> <span class="n">CompileError</span><span class="p">,</span> <span class="n">LostObjectError</span><span class="p">,</span> <span class="n">ClassInfoError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">storm.properties</span> <span class="k">import</span> <span class="n">PropertyColumn</span>
<span class="kn">from</span> <span class="nn">storm</span> <span class="k">import</span> <span class="n">Undef</span>
<span class="kn">from</span> <span class="nn">storm.cache</span> <span class="k">import</span> <span class="n">Cache</span>
<span class="kn">from</span> <span class="nn">storm.event</span> <span class="k">import</span> <span class="n">EventSystem</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Store&quot;</span><span class="p">,</span> <span class="s2">&quot;AutoReload&quot;</span><span class="p">,</span> <span class="s2">&quot;EmptyResultSet&quot;</span><span class="p">]</span>


<span class="n">PENDING_ADD</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">PENDING_REMOVE</span> <span class="o">=</span> <span class="mi">2</span>


<div class="viewcode-block" id="Store"><a class="viewcode-back" href="../../store.html#storm.store.Store">[docs]</a><span class="k">class</span> <span class="nc">Store</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The Storm Store.</span>

<span class="sd">    This is the highest-level interface to a database. It manages</span>
<span class="sd">    transactions with L{commit} and L{rollback}, caching, high-level</span>
<span class="sd">    querying with L{find}, and more.</span>

<span class="sd">    Note that Store objects are not threadsafe. You should create one</span>
<span class="sd">    Store per thread in your application, passing them the same</span>
<span class="sd">    backend L{Database&lt;storm.store.Database&gt;} object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_result_set_factory</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        @param database: The L{storm.database.Database} instance to use.</span>
<span class="sd">        @param cache: The cache to use.  Defaults to a L{Cache} instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_database</span> <span class="o">=</span> <span class="n">database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span> <span class="o">=</span> <span class="n">EventSystem</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># (info, info) = count</span>
        <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Advisory ordering.</span>

<div class="viewcode-block" id="Store.get_database"><a class="viewcode-back" href="../../store.html#storm.store.Store.get_database">[docs]</a>    <span class="k">def</span> <span class="nf">get_database</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return this Store&#39;s Database object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_database</span></div>

<div class="viewcode-block" id="Store.of"><a class="viewcode-back" href="../../store.html#storm.store.Store.of">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">of</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the Store that the object is associated with.</span>

<span class="sd">        If the given object has not yet been associated with a store,</span>
<span class="sd">        return None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;store&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">ClassInfoError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Store.execute"><a class="viewcode-back" href="../../store.html#storm.store.Store.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noresult</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a basic query.</span>

<span class="sd">        This is just like L{storm.database.Database.execute}, except</span>
<span class="sd">        that a flush is performed first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">noresult</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.close"><a class="viewcode-back" href="../../store.html#storm.store.Store.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close the connection.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="Store.begin"><a class="viewcode-back" href="../../store.html#storm.store.Store.begin">[docs]</a>    <span class="k">def</span> <span class="nf">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start a new two-phase transaction.</span>

<span class="sd">        @param xid: A L{Xid} instance holding identification data for the</span>
<span class="sd">            new transaction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">xid</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.prepare"><a class="viewcode-back" href="../../store.html#storm.store.Store.prepare">[docs]</a>    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare a two-phase transaction for the final commit.</span>

<span class="sd">        @note: It must be call inside a two-phase transaction started</span>
<span class="sd">            with begin().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span></div>

<div class="viewcode-block" id="Store.commit"><a class="viewcode-back" href="../../store.html#storm.store.Store.commit">[docs]</a>    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Commit all changes to the database.</span>

<span class="sd">        This invalidates the cache, so all live objects will have data</span>
<span class="sd">        reloaded next time they are touched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span></div>

<div class="viewcode-block" id="Store.rollback"><a class="viewcode-back" href="../../store.html#storm.store.Store.rollback">[docs]</a>    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Roll back all outstanding changes, reverting to database state.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">obj_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">:</span>
            <span class="n">pending</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;pending&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pending</span> <span class="ow">is</span> <span class="n">PENDING_ADD</span><span class="p">:</span>
                <span class="c1"># Object never got in the cache, so being &quot;in the store&quot;</span>
                <span class="c1"># has no actual meaning for it.</span>
                <span class="k">del</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pending</span> <span class="ow">is</span> <span class="n">PENDING_REMOVE</span><span class="p">:</span>
                <span class="c1"># Object never got removed, so it&#39;s still in the cache,</span>
                <span class="c1"># and thus should continue to resolve from now on.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_enable_lazy_resolving</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span></div>

<div class="viewcode-block" id="Store.get"><a class="viewcode-back" href="../../store.html#storm.store.Store.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get object of type cls with the given primary key from the database.</span>

<span class="sd">        If the object is alive the database won&#39;t be touched.</span>

<span class="sd">        @param cls: Class of the object to be retrieved.</span>
<span class="sd">        @param key: Primary key of object. May be a tuple for composed keys.</span>

<span class="sd">        @return: The object found with the given primary key, or None</span>
<span class="sd">            if no object is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>

        <span class="n">cls_info</span> <span class="o">=</span> <span class="n">get_cls_info</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">)</span>

        <span class="n">primary_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">iter_zip</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">variable_factory</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">variable</span><span class="p">)</span>
            <span class="n">primary_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

        <span class="n">primary_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">to_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">primary_vars</span><span class="p">)</span>
        <span class="n">obj_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">cls_info</span><span class="o">.</span><span class="n">cls</span><span class="p">,</span> <span class="n">primary_values</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">obj_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;invalidated&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>

        <span class="n">where</span> <span class="o">=</span> <span class="n">compare_columns</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span> <span class="n">primary_vars</span><span class="p">)</span>

        <span class="n">select</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span>
                        <span class="n">default_tables</span><span class="o">=</span><span class="n">cls_info</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_object</span><span class="p">(</span><span class="n">cls_info</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.find"><a class="viewcode-back" href="../../store.html#storm.store.Store.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls_spec</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a query.</span>

<span class="sd">        Some examples::</span>

<span class="sd">            store.find(Person, Person.name == u&quot;Joe&quot;) --&gt; all Persons named Joe</span>
<span class="sd">            store.find(Person, name=u&quot;Joe&quot;) --&gt; same</span>
<span class="sd">            store.find((Company, Person), Person.company_id == Company.id) --&gt;</span>
<span class="sd">                iterator of tuples of Company and Person instances which are</span>
<span class="sd">                associated via the company_id -&gt; Company relation.</span>

<span class="sd">        @param cls_spec: The class or tuple of classes whose</span>
<span class="sd">            associated tables will be queried.</span>
<span class="sd">        @param args: Instances of L{Expr}.</span>
<span class="sd">        @param kwargs: Mapping of simple column names to values or</span>
<span class="sd">            expressions to query for.</span>

<span class="sd">        @return: A L{ResultSet} of instances C{cls_spec}. If C{cls_spec}</span>
<span class="sd">            was a tuple, then an iterator of tuples of such instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">find_spec</span> <span class="o">=</span> <span class="n">FindSpec</span><span class="p">(</span><span class="n">cls_spec</span><span class="p">)</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">get_where_for_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">find_spec</span><span class="o">.</span><span class="n">default_cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_result_set_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">find_spec</span><span class="p">,</span> <span class="n">where</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.using"><a class="viewcode-back" href="../../store.html#storm.store.Store.using">[docs]</a>    <span class="k">def</span> <span class="nf">using</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify tables to use explicitly.</span>

<span class="sd">        The L{find} method generally does a good job at figuring out</span>
<span class="sd">        the tables to query by itself, but in some cases it&#39;s useful</span>
<span class="sd">        to specify them explicitly.</span>

<span class="sd">        This is most often necessary when an explicit SQL join is</span>
<span class="sd">        required. An example follows::</span>

<span class="sd">            join = LeftJoin(Person, Person.id == Company.person_id)</span>
<span class="sd">            print list(store.using(Company, join).find((Company, Person)))</span>

<span class="sd">        The previous code snippet will produce an SQL statement</span>
<span class="sd">        somewhat similar to this, depending on your backend::</span>

<span class="sd">            SELECT company.id, employee.company_id, employee.id</span>
<span class="sd">            FROM company</span>
<span class="sd">            LEFT JOIN employee ON employee.company_id = company.id;</span>

<span class="sd">        @return: A L{TableSet}, which has a C{find} method similar to</span>
<span class="sd">            L{Store.find}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tables</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.add"><a class="viewcode-back" href="../../store.html#storm.store.Store.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the given object to the store.</span>

<span class="sd">        The object will be inserted into the database if it has not</span>
<span class="sd">        yet been added.</span>

<span class="sd">        The C{added} event will be fired on the object info&#39;s event system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;register-transaction&quot;</span><span class="p">)</span>
        <span class="n">obj_info</span> <span class="o">=</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">store</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;store&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongStoreError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is part of another store&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

        <span class="n">pending</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pending&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pending</span> <span class="ow">is</span> <span class="n">PENDING_ADD</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">pending</span> <span class="ow">is</span> <span class="n">PENDING_REMOVE</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;pending&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enable_lazy_resolving</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="c1"># obj_info.event.emit(&quot;added&quot;)</span>
        <span class="k">elif</span> <span class="n">store</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;pending&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PENDING_ADD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_dirty</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enable_lazy_resolving</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;added&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="Store.remove"><a class="viewcode-back" href="../../store.html#storm.store.Store.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the given object from the store.</span>

<span class="sd">        The associated row will be deleted from the database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;register-transaction&quot;</span><span class="p">)</span>
        <span class="n">obj_info</span> <span class="o">=</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;store&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongStoreError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not in this store&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

        <span class="n">pending</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pending&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pending</span> <span class="ow">is</span> <span class="n">PENDING_REMOVE</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">pending</span> <span class="ow">is</span> <span class="n">PENDING_ADD</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;pending&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_clean</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_disable_lazy_resolving</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;removed&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;pending&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PENDING_REMOVE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_dirty</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_disable_lazy_resolving</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;removed&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.reload"><a class="viewcode-back" href="../../store.html#storm.store.Store.reload">[docs]</a>    <span class="k">def</span> <span class="nf">reload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reload the given object.</span>

<span class="sd">        The object will immediately have all of its data reset from</span>
<span class="sd">        the database. Any pending changes will be thrown away.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj_info</span> <span class="o">=</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">cls_info</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span>
        <span class="k">if</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;store&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongStoreError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not in this store&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;primary_vars&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj_info</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotFlushedError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t reload an object if it was &quot;</span>
                                  <span class="s2">&quot;never flushed&quot;</span><span class="p">)</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">compare_columns</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">])</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span>
                        <span class="n">default_tables</span><span class="o">=</span><span class="n">cls_info</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                         <span class="n">replace_unknown_lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_clean</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.autoreload"><a class="viewcode-back" href="../../store.html#storm.store.Store.autoreload">[docs]</a>    <span class="k">def</span> <span class="nf">autoreload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an object or all objects to be reloaded automatically on access.</span>

<span class="sd">        When a database-backed attribute of one of the objects is</span>
<span class="sd">        accessed, the object will be reloaded entirely from the database.</span>

<span class="sd">        @param obj: If passed, only mark the given object for</span>
<span class="sd">            autoreload. Otherwise, all cached objects will be marked for</span>
<span class="sd">            autoreload.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark_autoreload</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.invalidate"><a class="viewcode-back" href="../../store.html#storm.store.Store.invalidate">[docs]</a>    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an object or all objects to be invalidated.</span>

<span class="sd">        This prevents Storm from returning the cached object without</span>
<span class="sd">        first verifying that the object is still available in the</span>
<span class="sd">        database.</span>

<span class="sd">        This should almost never be called by application code; it is</span>
<span class="sd">        only necessary if it is possible that an object has</span>
<span class="sd">        disappeared through some mechanism that Storm was unable to</span>
<span class="sd">        detect, like direct SQL statements within the current</span>
<span class="sd">        transaction that bypassed the ORM layer. The Store</span>
<span class="sd">        automatically invalidates all cached objects on transaction</span>
<span class="sd">        boundaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">get_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark_autoreload</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Store.reset"><a class="viewcode-back" href="../../store.html#storm.store.Store.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset this store, causing all future queries to return new objects.</span>

<span class="sd">        Beware this method: it breaks the assumption that there will never be</span>
<span class="sd">        two objects in memory which represent the same database object.</span>

<span class="sd">        This is useful if you&#39;ve got in-memory changes to an object that you</span>
<span class="sd">        want to &quot;throw out&quot;; next time they&#39;re fetched the objects will be</span>
<span class="sd">        recreated, so in-memory modifications will not be in effect for future</span>
<span class="sd">        queries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">obj_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_alive</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;store&quot;</span> <span class="ow">in</span> <span class="n">obj_info</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># The following line is untested, but then, I can&#39;t really find a way</span>
        <span class="c1"># to test it without whitebox.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_mark_autoreload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">invalidate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj_infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_alive</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj_infos</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">),)</span>
        <span class="k">for</span> <span class="n">obj_info</span> <span class="ow">in</span> <span class="n">obj_infos</span><span class="p">:</span>
            <span class="n">cls_info</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key_idx</span><span class="p">:</span>
                    <span class="n">obj_info</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">AutoReload</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">invalidate</span><span class="p">:</span>
                <span class="c1"># Marking an object with &#39;invalidated&#39; means that we&#39;re</span>
                <span class="c1"># not sure if the object is actually in the database</span>
                <span class="c1"># anymore, so before the object is returned from the cache</span>
                <span class="c1"># (e.g. by a get()), the database should be queried to see</span>
                <span class="c1"># if the object&#39;s still there.</span>
                <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;invalidated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># We want to make sure we&#39;ve marked all objects as invalidated and set</span>
        <span class="c1"># up their autoreloads before calling the invalidated hook on *any* of</span>
        <span class="c1"># them, because an invalidated hook might use other objects and we want</span>
        <span class="c1"># to prevent invalidation ordering issues.</span>
        <span class="k">if</span> <span class="n">invalidate</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj_info</span> <span class="ow">in</span> <span class="n">obj_infos</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_run_hook</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="s2">&quot;__storm_invalidated__&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Store.add_flush_order"><a class="viewcode-back" href="../../store.html#storm.store.Store.add_flush_order">[docs]</a>    <span class="k">def</span> <span class="nf">add_flush_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Explicitly specify the order of flushing two objects.</span>

<span class="sd">        When the next database flush occurs, the order of data</span>
<span class="sd">        modification statements will be ensured.</span>

<span class="sd">        @param before: The object to flush first.</span>
<span class="sd">        @param after: The object to flush after C{before}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_obj_info</span><span class="p">(</span><span class="n">before</span><span class="p">),</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">after</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Store.remove_flush_order"><a class="viewcode-back" href="../../store.html#storm.store.Store.remove_flush_order">[docs]</a>    <span class="k">def</span> <span class="nf">remove_flush_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cancel an explicit flush order specified with L{add_flush_order}.</span>

<span class="sd">        @param before: The C{before} object previously specified in a</span>
<span class="sd">            call to L{add_flush_order}.</span>
<span class="sd">        @param after: The C{after} object previously specified in a</span>
<span class="sd">            call to L{add_flush_order}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_obj_info</span><span class="p">(</span><span class="n">before</span><span class="p">),</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">after</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Store.flush"><a class="viewcode-back" href="../../store.html#storm.store.Store.flush">[docs]</a>    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush all dirty objects in cache to database.</span>

<span class="sd">        This method will first call the __storm_pre_flush__ hook of all dirty</span>
<span class="sd">        objects.  If more objects become dirty as a result of executing code</span>
<span class="sd">        in the hooks, the hook is also called on them.  The hook is only</span>
<span class="sd">        called once for each object.</span>

<span class="sd">        It will then flush each dirty object to the database, that is,</span>
<span class="sd">        execute the SQL code to insert/delete/update them.  After each</span>
<span class="sd">        object is flushed, the hook __storm_flushed__ is called on it,</span>
<span class="sd">        and if changes are made to the object it will get back to the</span>
<span class="sd">        dirty list, and be flushed again.</span>

<span class="sd">        Note that Storm will flush objects for you automatically, so you&#39;ll</span>
<span class="sd">        only need to call this method explicitly in very rare cases where</span>
<span class="sd">        normal flushing times are insufficient, such as when you want to</span>
<span class="sd">        make sure a database trigger gets run at a particular time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;flush&quot;</span><span class="p">)</span>

        <span class="c1"># The _dirty list may change under us while we&#39;re running</span>
        <span class="c1"># the flush hooks, so we cannot just simply loop over it</span>
        <span class="c1"># once.  To prevent infinite looping we keep track of which</span>
        <span class="c1"># objects we&#39;ve called the hook for using a `flushing` dict.</span>
        <span class="n">flushing</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">:</span>
            <span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">obj_info</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">flushing</span><span class="p">:</span>
                <span class="n">flushing</span><span class="p">[</span><span class="n">obj_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_run_hook</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="s2">&quot;__storm_pre_flush__&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span> <span class="o">=</span> <span class="n">flushing</span>

        <span class="n">predecessors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">before_info</span><span class="p">,</span> <span class="n">after_info</span><span class="p">),</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">iter_items</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">before_set</span> <span class="o">=</span> <span class="n">predecessors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">after_info</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">before_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">predecessors</span><span class="p">[</span><span class="n">after_info</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">before_info</span><span class="p">,))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">before_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">before_info</span><span class="p">)</span>

        <span class="n">key_func</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="s2">&quot;sequence&quot;</span><span class="p">)</span>

        <span class="c1"># The external loop is important because items can get into the dirty</span>
        <span class="c1"># state while we&#39;re flushing objects, ...</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">:</span>
            <span class="c1"># ... but we don&#39;t have to resort everytime an object is flushed,</span>
            <span class="c1"># so we have an internal loop too.  If no objects become dirty</span>
            <span class="c1"># during flush, this will clean self._dirty and the external loop</span>
            <span class="c1"># will exit too.</span>
            <span class="n">sorted_dirty</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key_func</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">sorted_dirty</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj_info</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_dirty</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">before_info</span> <span class="ow">in</span> <span class="n">predecessors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="p">()):</span>
                        <span class="k">if</span> <span class="n">before_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">:</span>
                            <span class="k">break</span> <span class="c1"># A predecessor is still dirty.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span> <span class="c1"># Found an item without dirty predecessors.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">OrderLoopError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t flush due to ordering loop&quot;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">sorted_dirty</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flush_one</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># That&#39;s not stricly necessary, but prevents getting into bigints.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="k">def</span> <span class="nf">_flush_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="n">cls_info</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span>

        <span class="n">pending</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;pending&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pending</span> <span class="ow">is</span> <span class="n">PENDING_REMOVE</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">Delete</span><span class="p">(</span><span class="n">compare_columns</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span>
                                          <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">]),</span>
                          <span class="n">cls_info</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">noresult</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># We&#39;re sure the cache is valid at this point.</span>
            <span class="n">obj_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;invalidated&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_disable_change_notification</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_from_alive</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">pending</span> <span class="ow">is</span> <span class="n">PENDING_ADD</span><span class="p">:</span>

            <span class="c1"># Give a chance to the backend to process primary variables.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">preset_primary_key</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span>
                                                <span class="n">obj_info</span><span class="o">.</span><span class="n">primary_vars</span><span class="p">)</span>

            <span class="n">changes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_changes_map</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="n">expr</span> <span class="o">=</span> <span class="n">Insert</span><span class="p">(</span><span class="n">changes</span><span class="p">,</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">table</span><span class="p">,</span>
                          <span class="n">primary_columns</span><span class="o">=</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span>
                          <span class="n">primary_variables</span><span class="o">=</span><span class="n">obj_info</span><span class="o">.</span><span class="n">primary_vars</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

            <span class="c1"># We&#39;re sure the cache is valid at this point. We just added</span>
            <span class="c1"># the object.</span>
            <span class="n">obj_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;invalidated&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_missing_values</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">primary_vars</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_enable_change_notification</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_alive</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cached_primary_vars</span> <span class="o">=</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">]</span>

            <span class="n">changes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_changes_map</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">changes</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">Update</span><span class="p">(</span><span class="n">changes</span><span class="p">,</span>
                              <span class="n">compare_columns</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span>
                                              <span class="n">cached_primary_vars</span><span class="p">),</span>
                              <span class="n">cls_info</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">noresult</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_fill_missing_values</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">primary_vars</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_alive</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_run_hook</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="s2">&quot;__storm_flushed__&quot;</span><span class="p">)</span>

        <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;flushed&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Store.block_implicit_flushes"><a class="viewcode-back" href="../../store.html#storm.store.Store.block_implicit_flushes">[docs]</a>    <span class="k">def</span> <span class="nf">block_implicit_flushes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Block implicit flushes from operations like execute().&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Store.unblock_implicit_flushes"><a class="viewcode-back" href="../../store.html#storm.store.Store.unblock_implicit_flushes">[docs]</a>    <span class="k">def</span> <span class="nf">unblock_implicit_flushes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unblock implicit flushes from operations like execute().&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">-=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Store.block_access"><a class="viewcode-back" href="../../store.html#storm.store.Store.block_access">[docs]</a>    <span class="k">def</span> <span class="nf">block_access</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Block access to the underlying database connection.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">block_access</span><span class="p">()</span></div>

<div class="viewcode-block" id="Store.unblock_access"><a class="viewcode-back" href="../../store.html#storm.store.Store.unblock_access">[docs]</a>    <span class="k">def</span> <span class="nf">unblock_access</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unblock access to the underlying database connection.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">unblock_access</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_get_changes_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">,</span> <span class="n">adding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a {column: variable} dictionary suitable for inserts/updates.</span>

<span class="sd">        @param obj_info: ObjectInfo to inspect for changes.</span>
<span class="sd">        @param adding: If true, any defined variables will be considered</span>
<span class="sd">                       a change and included in the returned map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls_info</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">select_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">adding</span> <span class="ow">or</span> <span class="n">variable</span><span class="o">.</span><span class="n">has_changed</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_defined</span><span class="p">():</span>
                    <span class="n">changes</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lazy_value</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">get_lazy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lazy_value</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key_idx</span><span class="p">:</span>
                            <span class="n">select_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="c1"># See below.</span>
                            <span class="n">changes</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">changes</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">lazy_value</span>

        <span class="c1"># If we have any expressions in the primary variables, we</span>
        <span class="c1"># have to resolve them now so that we have the identity of</span>
        <span class="c1"># the inserted object available later.</span>
        <span class="k">if</span> <span class="n">select_variables</span><span class="p">:</span>
            <span class="n">resolve_expr</span> <span class="o">=</span> <span class="n">Select</span><span class="p">([</span><span class="n">variable</span><span class="o">.</span><span class="n">get_lazy</span><span class="p">()</span>
                                   <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">select_variables</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">resolve_expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iter_zip</span><span class="p">(</span><span class="n">select_variables</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">changes</span>

    <span class="k">def</span> <span class="nf">_fill_missing_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">,</span> <span class="n">primary_vars</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill missing values in variables of the given obj_info.</span>

<span class="sd">        This method will verify which values are unset in obj_info,</span>
<span class="sd">        and set them to AutoReload, or if it&#39;s part of the primary</span>
<span class="sd">        key, query the database for the actual values.</span>

<span class="sd">        @param obj_info: ObjectInfo to have its values filled.</span>
<span class="sd">        @param primary_vars: Variables composing the primary key with</span>
<span class="sd">            up-to-date values (cached variables may be out-of-date when</span>
<span class="sd">            this method is called).</span>
<span class="sd">        @param result: If some value in the set of primary variables</span>
<span class="sd">            isn&#39;t defined, it must be retrieved from the database</span>
<span class="sd">            using database-dependent logic, which is provided by the</span>
<span class="sd">            backend in the result of the query which inserted the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls_info</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span>

        <span class="n">cached_primary_vars</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">)</span>
        <span class="n">primary_key_idx</span> <span class="o">=</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key_idx</span>
        <span class="n">missing_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_defined</span><span class="p">():</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">primary_key_idx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">cached_primary_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="ow">and</span> <span class="n">variable</span><span class="o">.</span><span class="n">get_lazy</span><span class="p">()</span> <span class="ow">is</span> <span class="n">AutoReload</span><span class="p">):</span>
                        <span class="c1"># For auto-reloading a primary key, just</span>
                        <span class="c1"># get the value out of the cache.</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cached_primary_vars</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">missing_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Any lazy values are overwritten here.  This value</span>
                    <span class="c1"># must have just been sent to the database, so this</span>
                    <span class="c1"># was already set there.</span>
                    <span class="n">variable</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">AutoReload</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">missing_columns</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_insert_identity</span><span class="p">(</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span>
                                               <span class="n">primary_vars</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">Select</span><span class="p">(</span><span class="n">missing_columns</span><span class="p">,</span> <span class="n">where</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">missing_columns</span><span class="p">,</span>
                             <span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_validate_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform cache validation for the given obj_info.&quot;&quot;&quot;</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">compare_columns</span><span class="p">(</span><span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span>
                                <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">Select</span><span class="p">(</span><span class="n">SQLRaw</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">),</span> <span class="n">where</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">LostObjectError</span><span class="p">(</span><span class="s2">&quot;Object is not in the database anymore&quot;</span><span class="p">)</span>
        <span class="n">obj_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;invalidated&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls_info</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># _set_values() need the cls_info columns for the class of the</span>
        <span class="c1"># actual object, not from a possible wrapper (e.g. an alias).</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">cls</span>
        <span class="n">cls_info</span> <span class="o">=</span> <span class="n">get_cls_info</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="c1"># Prepare cache key.</span>
        <span class="n">primary_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span>

        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We&#39;ve got a row full of NULLs, so consider that the object</span>
            <span class="c1"># wasn&#39;t found.  This is useful for joins, where non-existent</span>
            <span class="c1"># rows are represented like that.</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key_pos</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">variable_factory</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">from_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">primary_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

        <span class="c1"># Lookup cache.</span>
        <span class="n">primary_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">to_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">primary_vars</span><span class="p">)</span>
        <span class="n">obj_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="bp">cls</span><span class="p">,</span> <span class="n">primary_values</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">obj_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Found object in cache, and it must be valid since the</span>
            <span class="c1"># primary key was extracted from result values.</span>
            <span class="n">obj_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;invalidated&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Take that chance and fill up any undefined variables</span>
            <span class="c1"># with fresh data, since we got it anyway.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
                             <span class="n">values</span><span class="p">,</span> <span class="n">keep_defined</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># We&#39;re not sure if the obj is still in memory at this</span>
            <span class="c1"># point.  This will rebuild it if needed.</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Nothing found in the cache. Build everything from the ground.</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="n">obj_info</span> <span class="o">=</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;store&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                             <span class="n">replace_unknown_lazy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_alive</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enable_change_notification</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enable_lazy_resolving</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_run_hook</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="s2">&quot;__storm_loaded__&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_get_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return object for obj_info, rebuilding it if it&#39;s dead.&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get_obj</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span><span class="o">.</span><span class="n">cls</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="n">obj_info</span><span class="o">.</span><span class="n">set_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">set_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">)</span>
            <span class="c1"># Re-enable change notification, as it may have been implicitely</span>
            <span class="c1"># disabled when the previous object has been collected</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enable_change_notification</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_run_hook</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="s2">&quot;__storm_loaded__&quot;</span><span class="p">)</span>
        <span class="c1"># Renew the cache.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_run_hook</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">hook_name</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj_info</span><span class="o">.</span><span class="n">get_obj</span><span class="p">(),</span> <span class="n">hook_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                    <span class="n">keep_defined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">replace_unknown_lazy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LostObjectError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t obtain values from the database &quot;</span>
                                  <span class="s2">&quot;(object got removed?)&quot;</span><span class="p">)</span>
        <span class="n">obj_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;invalidated&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iter_zip</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
            <span class="n">lazy_value</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">get_lazy</span><span class="p">()</span>
            <span class="n">is_unknown_lazy</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lazy_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                                   <span class="n">lazy_value</span> <span class="ow">is</span> <span class="n">AutoReload</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keep_defined</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_defined</span><span class="p">()</span> <span class="ow">or</span> <span class="n">is_unknown_lazy</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">is_unknown_lazy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">replace_unknown_lazy</span><span class="p">:</span>
                <span class="c1"># This should *never* happen, because whenever we get</span>
                <span class="c1"># to this point it should be after a flush() which</span>
                <span class="c1"># updated the database with lazy values and then replaced</span>
                <span class="c1"># them by AutoReload.  Letting this go through means</span>
                <span class="c1"># we&#39;re blindly discarding an unknown lazy value and</span>
                <span class="c1"># replacing it by the value from the database.</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unexpected situation. &quot;</span>
                                   <span class="s2">&quot;Please contact the developers.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">from_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="n">variable</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_is_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span>

    <span class="k">def</span> <span class="nf">_set_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj_info</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">[</span><span class="n">obj_info</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get_obj</span><span class="p">()</span>
            <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;sequence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_set_clean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span>


    <span class="k">def</span> <span class="nf">_add_to_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an object to the set of known in-memory objects.</span>

<span class="sd">        When an object is added to the set of known in-memory objects,</span>
<span class="sd">        the key is built from a copy of the current variables that are</span>
<span class="sd">        part of the primary key.  This means that, when an object is</span>
<span class="sd">        retrieved from the database, these values may be used to get</span>
<span class="sd">        the cached object which is already in memory, even if it</span>
<span class="sd">        requested the primary key value to be changed.  For that reason,</span>
<span class="sd">        when changes to the primary key are flushed, the alive object</span>
<span class="sd">        key should also be updated to reflect these changes.</span>

<span class="sd">        In addition to tracking objects alive in memory, we have a strong</span>
<span class="sd">        reference cache which keeps a fixed number of last-used objects</span>
<span class="sd">        in-memory, to prevent further database access for recently fetched</span>
<span class="sd">        objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls_info</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span>
        <span class="n">old_primary_vars</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old_primary_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_primary_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">to_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">old_primary_vars</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="o">.</span><span class="n">pop</span><span class="p">((</span><span class="n">cls_info</span><span class="o">.</span><span class="n">cls</span><span class="p">,</span> <span class="n">old_primary_values</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new_primary_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                 <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">primary_vars</span><span class="p">)</span>
        <span class="n">new_primary_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">to_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">new_primary_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="p">[</span><span class="n">cls_info</span><span class="o">.</span><span class="n">cls</span><span class="p">,</span> <span class="n">new_primary_values</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_info</span>
        <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_primary_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_from_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove an object from the cache.</span>

<span class="sd">        This method is only called for objects that were explicitly</span>
<span class="sd">        deleted and flushed.  Objects that are unused will get removed</span>
<span class="sd">        from the cache dictionary automatically by their weakref callbacks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">primary_vars</span> <span class="o">=</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">primary_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
            <span class="n">primary_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">to_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">primary_vars</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="p">[</span><span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span><span class="o">.</span><span class="n">cls</span><span class="p">,</span> <span class="n">primary_values</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_iter_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We need a list here since alive may be mutated while iterating</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">iter_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_enable_change_notification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;start-tracking-changes&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="p">)</span>
        <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">hook</span><span class="p">(</span><span class="s2">&quot;changed&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_changed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_disable_change_notification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">unhook</span><span class="p">(</span><span class="s2">&quot;changed&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_changed</span><span class="p">)</span>
        <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;stop-tracking-changes&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_variable_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span>
                          <span class="n">old_value</span><span class="p">,</span> <span class="n">new_value</span><span class="p">,</span> <span class="n">fromdb</span><span class="p">):</span>
        <span class="c1"># The fromdb check makes sure that values coming from the</span>
        <span class="c1"># database don&#39;t mark the object as dirty again.</span>
        <span class="c1"># XXX The fromdb check is untested. How to test it?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fromdb</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span> <span class="ow">and</span> <span class="n">new_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">AutoReload</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;invalidated&quot;</span><span class="p">):</span>
                    <span class="c1"># This might be a previously alive object being</span>
                    <span class="c1"># updated.  Let&#39;s validate it now to improve debugging.</span>
                    <span class="c1"># This will raise LostObjectError if the object is gone.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_validate_alive</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_dirty</span><span class="p">(</span><span class="n">obj_info</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_enable_lazy_resolving</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">hook</span><span class="p">(</span><span class="s2">&quot;resolve-lazy-value&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_lazy_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_disable_lazy_resolving</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">):</span>
        <span class="n">obj_info</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">unhook</span><span class="p">(</span><span class="s2">&quot;resolve-lazy-value&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_lazy_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_resolve_lazy_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_info</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">lazy_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resolve a variable set to a lazy value when it&#39;s touched.</span>

<span class="sd">        This method is hooked into the obj_info to resolve variables</span>
<span class="sd">        set to lazy values when they&#39;re accessed.  It will first flush</span>
<span class="sd">        the store, and then set all variables set to AutoReload to</span>
<span class="sd">        their database values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lazy_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">AutoReload</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lazy_value</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="c1"># It&#39;s not something we handle.</span>
            <span class="k">return</span>

        <span class="c1"># XXX This will do it for now, but it should really flush</span>
        <span class="c1">#     just this single object and ones that it depends on.</span>
        <span class="c1">#     _flush_one() doesn&#39;t consider dependencies, so it may</span>
        <span class="c1">#     not be used directly.  Maybe allow flush(obj)?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">autoreload_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">get_lazy</span><span class="p">()</span> <span class="ow">is</span> <span class="n">AutoReload</span><span class="p">:</span>
                <span class="n">autoreload_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">autoreload_columns</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">compare_columns</span><span class="p">(</span><span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">,</span>
                                    <span class="n">obj_info</span><span class="p">[</span><span class="s2">&quot;primary_vars&quot;</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">autoreload_columns</span><span class="p">,</span> <span class="n">where</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">obj_info</span><span class="p">,</span> <span class="n">autoreload_columns</span><span class="p">,</span>
                             <span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">())</span></div>


<span class="k">class</span> <span class="nc">ResultSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The representation of the results of a query.</span>

<span class="sd">    Note that having an instance of this class does not indicate that</span>
<span class="sd">    a database query has necessarily been made. Database queries are</span>
<span class="sd">    put off until absolutely necessary.</span>

<span class="sd">    Generally these should not be constructed directly, but instead</span>
<span class="sd">    retrieved from calls to L{Store.find}.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">find_spec</span><span class="p">,</span>
                 <span class="n">where</span><span class="o">=</span><span class="n">Undef</span><span class="p">,</span> <span class="n">tables</span><span class="o">=</span><span class="n">Undef</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="n">Undef</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="o">=</span> <span class="n">store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span> <span class="o">=</span> <span class="n">find_spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_where</span> <span class="o">=</span> <span class="n">where</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span> <span class="o">=</span> <span class="n">tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="o">=</span> <span class="n">select</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="n">find_spec</span><span class="o">.</span><span class="n">default_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">Undef</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">Undef</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="n">Undef</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="n">Undef</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of this ResultSet object, with the same configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_set</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">result_set</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="c1"># This expression must be copied because we may have to change it</span>
            <span class="c1"># in-place inside _get_select().</span>
            <span class="n">result_set</span><span class="o">.</span><span class="n">_select</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_set</span>

    <span class="k">def</span> <span class="nf">config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure this result object in-place. All parameters are optional.</span>

<span class="sd">        @param distinct: If True, enables usage of the DISTINCT keyword in</span>
<span class="sd">            the query. If a tuple or list of columns, inserts a DISTINCT ON</span>
<span class="sd">            (only supported by PostgreSQL).</span>
<span class="sd">        @param offset: Offset where results will start to be retrieved</span>
<span class="sd">            from the result set.</span>
<span class="sd">        @param limit: Limit the number of objects retrieved from the</span>
<span class="sd">            result set.</span>

<span class="sd">        @return: self (not a copy).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">distinct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="o">=</span> <span class="n">distinct</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_get_select</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span> <span class="c1"># XXX UNTESTED!</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span> <span class="c1"># XXX UNTESTED!</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span>
        <span class="n">columns</span><span class="p">,</span> <span class="n">default_tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">get_columns_and_tables</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Select</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">,</span> <span class="n">default_tables</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_limit</span><span class="p">,</span>
                      <span class="n">distinct</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span><span class="p">,</span> <span class="n">group_by</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span><span class="p">,</span>
                      <span class="n">having</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_having</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">load_objects</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate the results of the query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_objects</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an individual item by offset, or a range of items by slice.</span>

<span class="sd">        @return: The matching object or, if a slice is used, a new</span>
<span class="sd">            L{ResultSet} will be returned appropriately modified with</span>
<span class="sd">            C{OFFSET} and C{LIMIT} clauses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long_int</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result_set</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>
                <span class="n">result_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">result_set</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">result_set</span><span class="o">.</span><span class="n">_any</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t index ResultSets with </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Stepped slices not yet supported: </span><span class="si">%r</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">,))</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span>

        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span> <span class="o">-</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_limit</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_limit</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">index</span><span class="o">.</span><span class="n">start</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="n">Undef</span> <span class="ow">or</span> <span class="n">limit</span> <span class="o">&gt;</span> <span class="n">new_limit</span><span class="p">:</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">new_limit</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if an item is contained within the result set.&quot;&quot;&quot;</span>
        <span class="n">columns</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">get_columns_and_values_for_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="n">Undef</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="c1"># No predefined select: adjust the where clause.</span>
            <span class="n">dummy</span><span class="p">,</span> <span class="n">default_tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">get_columns_and_tables</span><span class="p">()</span>
            <span class="n">where</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">)</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">iter_zip</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">values</span><span class="p">)]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
                <span class="n">where</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">where</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">,</span>
                            <span class="n">default_tables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Rewrite the predefined query and use it as a subquery.</span>
            <span class="n">aliased_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">Alias</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">&quot;_key</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                               <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">)]</span>
            <span class="n">subquery</span> <span class="o">=</span> <span class="n">replace_columns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">(),</span> <span class="n">aliased_columns</span><span class="p">)</span>
            <span class="n">where</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">)</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">iter_zip</span><span class="p">(</span><span class="n">aliased_columns</span><span class="p">,</span> <span class="n">values</span><span class="p">)]</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">where</span><span class="p">),</span> <span class="n">Alias</span><span class="p">(</span><span class="n">subquery</span><span class="p">,</span> <span class="s2">&quot;_tmp&quot;</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return C{True} if this result set doesn&#39;t contain any results.&quot;&quot;&quot;</span>
        <span class="n">subselect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">()</span>
        <span class="n">subselect</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">subselect</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">Undef</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tables</span><span class="o">=</span><span class="n">Alias</span><span class="p">(</span><span class="n">subselect</span><span class="p">,</span> <span class="s2">&quot;_tmp&quot;</span><span class="p">),</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a single item from the result set.</span>

<span class="sd">        @return: An arbitrary object or C{None} if one isn&#39;t available.</span>
<span class="sd">        @seealso: one(), first(), and last().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">()</span>
        <span class="n">select</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">select</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">Undef</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_objects</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_any</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a single item from the result without changing sort order.</span>

<span class="sd">        @return: An arbitrary object or C{None} if one isn&#39;t available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">()</span>
        <span class="n">select</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_objects</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the first item from an ordered result set.</span>

<span class="sd">        @raises UnorderedError: Raised if the result set isn&#39;t ordered.</span>
<span class="sd">        @return: The first object or C{None} if one isn&#39;t available.</span>
<span class="sd">        @seealso: last(), one(), and any().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnorderedError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t use first() on unordered result set&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_any</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the last item from an ordered result set.</span>

<span class="sd">        @raises FeatureError: Raised if the result set has a C{LIMIT} set.</span>
<span class="sd">        @raises UnorderedError: Raised if the result set isn&#39;t ordered.</span>
<span class="sd">        @return: The last object or C{None} if one isn&#39;t available.</span>
<span class="sd">        @seealso: first(), one(), and any().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnorderedError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t use last() on unordered result set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t use last() with a slice &quot;</span>
                               <span class="s2">&quot;of defined stop index&quot;</span><span class="p">)</span>
        <span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">()</span>
        <span class="n">select</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">Undef</span>
        <span class="n">select</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">select</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Desc</span><span class="p">):</span>
                <span class="n">select</span><span class="o">.</span><span class="n">order_by</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Asc</span><span class="p">):</span>
                <span class="n">select</span><span class="o">.</span><span class="n">order_by</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Desc</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">select</span><span class="o">.</span><span class="n">order_by</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Desc</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_objects</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return one item from a result set containing at most one item.</span>

<span class="sd">        @raises NotOneError: Raised if the result set contains more than one</span>
<span class="sd">            item.</span>
<span class="sd">        @return: The object or C{None} if one isn&#39;t available.</span>
<span class="sd">        @seealso: first(), one(), and any().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">()</span>
        <span class="c1"># limit could be 1 due to slicing, for instance.</span>
        <span class="k">if</span> <span class="n">select</span><span class="o">.</span><span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span> <span class="ow">and</span> <span class="n">select</span><span class="o">.</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">select</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NotOneError</span><span class="p">(</span><span class="s2">&quot;one() used with more than one result available&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_objects</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify the ordering of the results.</span>

<span class="sd">        The query will be modified appropriately with an ORDER BY clause.</span>

<span class="sd">        Ascending and descending order can be specified by wrapping</span>
<span class="sd">        the columns in L{Asc} and L{Desc}.</span>

<span class="sd">        @param args: One or more L{storm.expr.Column} objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t reorder a sliced result set&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="n">args</span> <span class="ow">or</span> <span class="n">Undef</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all rows represented by this ResultSet from the database.</span>

<span class="sd">        This is done efficiently with a DELETE statement, so objects</span>
<span class="sd">        are not actually loaded into Python.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Removing isn&#39;t supported after a &quot;</span>
                               <span class="s2">&quot; GROUP BY clause &quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t remove a sliced result set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Removing not yet supported for tuple or &quot;</span>
                               <span class="s2">&quot;expression finds&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Removing isn&#39;t supported with &quot;</span>
                               <span class="s2">&quot;set expressions (unions, etc)&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="n">Delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls_info</span><span class="o">.</span><span class="n">table</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">rowcount</span>

    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Group this ResultSet by the given expressions.</span>

<span class="sd">        @param expr: The expressions used in the GROUP BY statement.</span>

<span class="sd">        @return: self (not a copy).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Grouping isn&#39;t supported with &quot;</span>
                               <span class="s2">&quot;set expressions (unions, etc)&quot;</span><span class="p">)</span>

        <span class="n">find_spec</span> <span class="o">=</span> <span class="n">FindSpec</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">columns</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">find_spec</span><span class="o">.</span><span class="n">get_columns_and_tables</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">having</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter result previously grouped by.</span>

<span class="sd">        @param expr: Instances of L{Expr}.</span>

<span class="sd">        @return: self (not a copy).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;having can only be called after group_by.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_having</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggregate_func</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Single aggregates aren&#39;t supported after a &quot;</span>
                               <span class="s2">&quot; GROUP BY clause &quot;</span><span class="p">)</span>
        <span class="n">columns</span><span class="p">,</span> <span class="n">default_tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">get_columns_and_tables</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="n">Undef</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distinct</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="n">Undef</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">):</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="n">aggregate_func</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">,</span> <span class="n">default_tables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
                <span class="n">aggregate</span> <span class="o">=</span> <span class="n">aggregate_func</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alias</span> <span class="o">=</span> <span class="n">Alias</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;_expr&quot;</span><span class="p">)</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                <span class="n">aggregate</span> <span class="o">=</span> <span class="n">aggregate_func</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
            <span class="c1"># Ordering probably doesn&#39;t matter for any aggregates, and since</span>
            <span class="c1"># replace_columns() blows up on an ordered query, we&#39;ll drop it.</span>
            <span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">()</span>
            <span class="n">select</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">Undef</span>
            <span class="n">subquery</span> <span class="o">=</span> <span class="n">replace_columns</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="n">aggregate</span><span class="p">,</span> <span class="n">tables</span><span class="o">=</span><span class="n">Alias</span><span class="p">(</span><span class="n">subquery</span><span class="p">,</span> <span class="s2">&quot;_tmp&quot;</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_one</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">variable_factory</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">&quot;variable_factory&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variable_factory</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">variable_factory</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">variable</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">Undef</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of objects represented by this ResultSet.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Count</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">distinct</span><span class="p">),</span> <span class="n">expr</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the highest value from an expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="n">Max</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the lowest value from an expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="n">Min</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the average value from an expression.&quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="n">Avg</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the sum of all values in an expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="n">Sum</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_select_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a L{Select} expression to retrieve only the specified columns.</span>

<span class="sd">        @param columns: One or more L{storm.expr.Column} objects whose values</span>
<span class="sd">            will be fetched.</span>
<span class="sd">        @raises FeatureError: Raised if no columns are specified or if this</span>
<span class="sd">            result is a set expression such as a union.</span>
<span class="sd">        @return: A L{Select} expression configured to use the query parameters</span>
<span class="sd">            specified for this result set, and also limited to only retrieving</span>
<span class="sd">            data for the specified columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;select() takes at least one column &quot;</span>
                               <span class="s2">&quot;as argument&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t generate subselect expression for set expressions&quot;</span><span class="p">)</span>
        <span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">()</span>
        <span class="n">select</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">return</span> <span class="n">select</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve only the specified columns.</span>

<span class="sd">        This does not load full objects from the database into Python.</span>

<span class="sd">        @param columns: One or more L{storm.expr.Column} objects whose</span>
<span class="sd">            values will be fetched.</span>
<span class="sd">        @raises FeatureError: Raised if no columns are specified or if this</span>
<span class="sd">            result is a set expression such as a union.</span>
<span class="sd">        @return: An iterator of tuples of the values for each column</span>
<span class="sd">            from each matching row in the database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;values() takes at least one column &quot;</span>
                               <span class="s2">&quot;as argument&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;values() can&#39;t be used with set expressions&quot;</span><span class="p">)</span>
        <span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">()</span>
        <span class="n">select</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">variable_factory</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">yield</span> <span class="n">variable</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">variable_factory</span><span class="p">()</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iter_zip</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update objects in the result set with the given arguments.</span>

<span class="sd">        This method will update all objects in the current result set</span>
<span class="sd">        to match expressions given as equalities or keyword arguments.</span>
<span class="sd">        These objects may still be in the database (an UPDATE is issued)</span>
<span class="sd">        or may be cached.</span>

<span class="sd">        For instance, C{result.set(Class.attr1 == 1, attr2=2)} will set</span>
<span class="sd">        C{attr1} to 1 and C{attr2} to 2, on all matching objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Setting isn&#39;t supported after a &quot;</span>
                               <span class="s2">&quot; GROUP BY clause &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Setting isn&#39;t supported with tuple or &quot;</span>
                               <span class="s2">&quot;expression finds&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Setting isn&#39;t supported with &quot;</span>
                               <span class="s2">&quot;set expressions (unions, etc)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">args</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">changes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls_info</span><span class="o">.</span><span class="n">cls</span>

        <span class="c1"># For now only &quot;Class.attr == var&quot; is supported in args.</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Eq</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Unsupported set expression: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
                                   <span class="nb">repr</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expr1</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Unsupported left operand in set &quot;</span>
                                   <span class="s2">&quot;expression: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expr1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expr2</span><span class="p">,</span> <span class="p">(</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Unsupported right operand in set &quot;</span>
                                   <span class="s2">&quot;expression: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expr2</span><span class="p">))</span>
            <span class="n">changes</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">expr1</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expr2</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iter_items</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">column</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">changes</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
                <span class="n">changes</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">changes</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">variable_factory</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">Update</span><span class="p">(</span><span class="n">changes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls_info</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">noresult</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">cached</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">CompileError</span><span class="p">:</span>
            <span class="c1"># We are iterating through all objects in memory here, so</span>
            <span class="c1"># check if the object type matches to avoid trying to</span>
            <span class="c1"># invalidate a column that does not exist, on an unrelated</span>
            <span class="c1"># object.</span>
            <span class="k">for</span> <span class="n">obj_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_iter_alive</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls_info</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">changes</span><span class="p">:</span>
                        <span class="n">obj_info</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">AutoReload</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We need a list here since we may iterate multiple times</span>
            <span class="n">changes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iter_items</span><span class="p">(</span><span class="n">changes</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">cached</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">changes</span><span class="p">:</span>
                    <span class="n">variables</span> <span class="o">=</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">variables</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
                        <span class="c1"># If the value is an Expression that means we</span>
                        <span class="c1"># can&#39;t compute it by ourselves: we rely on</span>
                        <span class="c1"># the database to compute it, so just set the</span>
                        <span class="c1"># value to AutoReload.</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">AutoReload</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return matching objects from the cache for the current query.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Cache finds not supported with tuples &quot;</span>
                               <span class="s2">&quot;or expressions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Cache finds not supported with custom tables&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">compile_python</span><span class="o">.</span><span class="n">get_matcher</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">get_column</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="n">objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_iter_alive</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls_info</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">match</span><span class="p">(</span><span class="n">get_column</span><span class="p">))):</span>
                    <span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_get_object</span><span class="p">(</span><span class="n">obj_info</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">LostObjectError</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1"># This may happen when resolving lazy values</span>
                     <span class="c1"># in get_column().</span>
        <span class="k">return</span> <span class="n">objects</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a query on objects within this result set.</span>

<span class="sd">        This is analogous to L{Store.find}, although it doesn&#39;t take a</span>
<span class="sd">        C{cls_spec} argument, instead using the same tables as the</span>
<span class="sd">        existing result set, and restricts the results to those in</span>
<span class="sd">        this set.</span>

<span class="sd">        @param args: Instances of L{Expr}.</span>
<span class="sd">        @param kwargs: Mapping of simple column names to values or</span>
<span class="sd">            expressions to query for.</span>

<span class="sd">        @return: A L{ResultSet} of matching instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t query set expressions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t query a sliced result set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t query grouped result sets&quot;</span><span class="p">)</span>

        <span class="n">result_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">extra_where</span> <span class="o">=</span> <span class="n">get_where_for_args</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">default_cls</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extra_where</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">result_set</span><span class="o">.</span><span class="n">_where</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
                <span class="n">result_set</span><span class="o">.</span><span class="n">_where</span> <span class="o">=</span> <span class="n">extra_where</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result_set</span><span class="o">.</span><span class="n">_where</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">result_set</span><span class="o">.</span><span class="n">_where</span><span class="p">,</span> <span class="n">extra_where</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_set</span>

    <span class="k">def</span> <span class="nf">_set_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr_cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_find_spec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Incompatible results for set operation&quot;</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr_cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_select</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_select</span><span class="p">(),</span> <span class="nb">all</span><span class="o">=</span><span class="nb">all</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ResultSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_spec</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the L{Union} of this result set and another.</span>

<span class="sd">        @param all: If True, include duplicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">EmptyResultSet</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_expr</span><span class="p">(</span><span class="n">Union</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="nb">all</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the difference, using L{Except}, of this result set and another.</span>

<span class="sd">        @param all: If True, include duplicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">EmptyResultSet</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_expr</span><span class="p">(</span><span class="n">Except</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="nb">all</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the L{Intersection} of this result set and another.</span>

<span class="sd">        @param all: If True, include duplicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">EmptyResultSet</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_expr</span><span class="p">(</span><span class="n">Intersect</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="nb">all</span><span class="p">)</span>


<div class="viewcode-block" id="EmptyResultSet"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet">[docs]</a><span class="k">class</span> <span class="nc">EmptyResultSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An object that looks like a L{ResultSet} but represents no rows.</span>

<span class="sd">    This is convenient for application developers who want to provide</span>
<span class="sd">    a method which is guaranteed to return a L{ResultSet}-like object</span>
<span class="sd">    but which, in certain cases, knows there is no point in querying</span>
<span class="sd">    the database. For example::</span>

<span class="sd">        def get_people(self, ids):</span>
<span class="sd">            if not ids:</span>
<span class="sd">                return EmptyResultSet()</span>
<span class="sd">            return store.find(People, People.id.is_in(ids))</span>

<span class="sd">    The methods on EmptyResultSet (L{one}, L{config}, L{union}, etc)</span>
<span class="sd">    are meant to emulate a L{ResultSet} which has matched no rows.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="n">ordered</span>

<div class="viewcode-block" id="EmptyResultSet.copy"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">EmptyResultSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="EmptyResultSet.config"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.config">[docs]</a>    <span class="k">def</span> <span class="nf">config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>
        <span class="k">yield</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="EmptyResultSet.is_empty"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.is_empty">[docs]</a>    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="EmptyResultSet.any"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.any">[docs]</a>    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="EmptyResultSet.first"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">raise</span> <span class="n">UnorderedError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t use first() on unordered result set&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmptyResultSet.last"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">raise</span> <span class="n">UnorderedError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t use last() on unordered result set&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmptyResultSet.one"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.one">[docs]</a>    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="EmptyResultSet.order_by"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.order_by">[docs]</a>    <span class="k">def</span> <span class="nf">order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="EmptyResultSet.group_by"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.group_by">[docs]</a>    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="EmptyResultSet.remove"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="EmptyResultSet.count"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">Undef</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="EmptyResultSet.max"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="EmptyResultSet.min"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="EmptyResultSet.avg"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.avg">[docs]</a>    <span class="k">def</span> <span class="nf">avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="EmptyResultSet.sum"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="EmptyResultSet.get_select_expr"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.get_select_expr">[docs]</a>    <span class="k">def</span> <span class="nf">get_select_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a L{Select} expression to retrieve only the specified columns.</span>

<span class="sd">        @param columns: One or more L{storm.expr.Column} objects whose values</span>
<span class="sd">            will be fetched.</span>
<span class="sd">        @raises FeatureError: Raised if no columns are specified.</span>
<span class="sd">        @return: A L{Select} expression configured to use the query parameters</span>
<span class="sd">            specified for this result set.  The result of the select will</span>
<span class="sd">            always be an empty set of rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;select() takes at least one column &quot;</span>
                               <span class="s2">&quot;as argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Select</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmptyResultSet.values"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;values() takes at least one column &quot;</span>
                               <span class="s2">&quot;as argument&quot;</span><span class="p">)</span>
        <span class="k">return</span>
        <span class="k">yield</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="EmptyResultSet.set"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="EmptyResultSet.cached"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.cached">[docs]</a>    <span class="k">def</span> <span class="nf">cached</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="EmptyResultSet.find"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="EmptyResultSet.union"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">EmptyResultSet</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmptyResultSet.difference"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.difference">[docs]</a>    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="EmptyResultSet.intersection"><a class="viewcode-back" href="../../store.html#storm.store.EmptyResultSet.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<span class="k">class</span> <span class="nc">TableSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The representation of a set of tables which can be queried at once.</span>

<span class="sd">    This will typically be constructed by a call to L{Store.using}.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">tables</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="o">=</span> <span class="n">store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span> <span class="o">=</span> <span class="n">tables</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls_spec</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a query on the previously specified tables.</span>

<span class="sd">        This is identical to L{Store.find} except that the tables are</span>
<span class="sd">        explicitly specified instead of relying on inference.</span>

<span class="sd">        @return: A L{ResultSet}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_implicit_flush_block_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">find_spec</span> <span class="o">=</span> <span class="n">FindSpec</span><span class="p">(</span><span class="n">cls_spec</span><span class="p">)</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">get_where_for_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">find_spec</span><span class="o">.</span><span class="n">default_cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">_result_set_factory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">,</span> <span class="n">find_spec</span><span class="p">,</span>
                                               <span class="n">where</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">)</span>


<span class="n">Store</span><span class="o">.</span><span class="n">_result_set_factory</span> <span class="o">=</span> <span class="n">ResultSet</span>
<span class="n">Store</span><span class="o">.</span><span class="n">_table_set</span> <span class="o">=</span> <span class="n">TableSet</span>


<span class="k">class</span> <span class="nc">FindSpec</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The set of tables or expressions in the result of L{Store.find}.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls_spec</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_tuple</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">cls_spec</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tuple</span><span class="p">:</span>
            <span class="n">cls_spec</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls_spec</span><span class="p">,)</span>

        <span class="n">info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cls_spec</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">True</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_cls_info</span><span class="p">(</span><span class="n">item</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_spec_info</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="c1"># Do we have a single non-expression item here?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tuple</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_cls</span> <span class="o">=</span> <span class="n">cls_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_cls_info</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_cls_info</span><span class="o">.</span><span class="n">default_order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_cls</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_cls_info</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_order</span> <span class="o">=</span> <span class="n">Undef</span>

    <span class="k">def</span> <span class="nf">get_columns_and_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">default_tables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">is_expr</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_spec_info</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_expr</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
                    <span class="n">default_tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">default_tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">columns</span><span class="p">,</span> <span class="n">default_tables</span>

    <span class="k">def</span> <span class="nf">is_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">find_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if this FindSpec is compatible with a second one.</span>

<span class="sd">        Two FindSpecs are considered compatible if either the find specs</span>
<span class="sd">        are identical (i.e. specifies the same classes and columns) or</span>
<span class="sd">        the find spec columns are of the same type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tuple</span> <span class="o">!=</span> <span class="n">find_spec</span><span class="o">.</span><span class="n">is_tuple</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_spec_info</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_spec</span><span class="o">.</span><span class="n">_cls_spec_info</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">is_expr1</span><span class="p">,</span> <span class="n">info1</span><span class="p">),</span> <span class="p">(</span><span class="n">is_expr2</span><span class="p">,</span> <span class="n">info2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iter_zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cls_spec_info</span><span class="p">,</span> <span class="n">find_spec</span><span class="o">.</span><span class="n">_cls_spec_info</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_expr1</span> <span class="o">!=</span> <span class="n">is_expr2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># If both infos are PropertyColumns, check whether they are</span>
            <span class="c1"># of the same type. Ideally we should check that the types as</span>
            <span class="c1"># defined in the database are the same, but checking the</span>
            <span class="c1"># variable class is easier and will work most of the time.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info1</span><span class="p">,</span> <span class="n">PropertyColumn</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info2</span><span class="p">,</span> <span class="n">PropertyColumn</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">variable_class1</span> <span class="o">=</span> <span class="n">info1</span><span class="o">.</span><span class="n">variable_factory</span><span class="p">()</span><span class="o">.</span><span class="vm">__class__</span>
                <span class="n">variable_class2</span> <span class="o">=</span> <span class="n">info2</span><span class="o">.</span><span class="n">variable_factory</span><span class="p">()</span><span class="o">.</span><span class="vm">__class__</span>
                <span class="k">if</span> <span class="n">variable_class1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">variable_class2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">info1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">info2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">load_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values_start</span> <span class="o">=</span> <span class="n">values_end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">is_expr</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_spec_info</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_expr</span><span class="p">:</span>
                <span class="n">values_end</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;variable_factory&quot;</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)(</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="n">values_start</span><span class="p">],</span> <span class="n">from_db</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values_end</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">_load_object</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
                                         <span class="n">values</span><span class="p">[</span><span class="n">values_start</span><span class="p">:</span><span class="n">values_end</span><span class="p">])</span>
                <span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">values_start</span> <span class="o">=</span> <span class="n">values_end</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tuple</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_columns_and_values_for_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a comparison expression with the given item.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tuple</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Find spec does not expect tuples.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tuple</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Find spec expects tuples.&quot;</span><span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,)</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">is_expr</span><span class="p">,</span> <span class="n">info</span><span class="p">),</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iter_zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_spec_info</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_expr</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Variable</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;variable_factory&quot;</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)(</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj_info</span> <span class="o">=</span> <span class="n">get_obj_info</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">obj_info</span><span class="o">.</span><span class="n">cls_info</span> <span class="o">!=</span> <span class="n">info</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> does not match </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">info</span><span class="p">))</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">primary_key</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">obj_info</span><span class="o">.</span><span class="n">primary_vars</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">columns</span><span class="p">,</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">get_where_for_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">equals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t determine class that keyword &quot;</span>
                               <span class="s2">&quot;arguments are associated with&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iter_items</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">equals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">equals</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">equals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Undef</span>


<span class="k">def</span> <span class="nf">replace_columns</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Select</span><span class="p">):</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">select</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="c1"># Remove the ordering if it won&#39;t affect the result of the query.</span>
        <span class="k">if</span> <span class="n">select</span><span class="o">.</span><span class="n">limit</span> <span class="ow">is</span> <span class="n">Undef</span> <span class="ow">and</span> <span class="n">select</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="n">Undef</span><span class="p">:</span>
            <span class="n">select</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">Undef</span>
        <span class="k">return</span> <span class="n">select</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">SetExpr</span><span class="p">):</span>
        <span class="c1"># The ORDER BY clause might refer to columns we have replaced.</span>
        <span class="c1"># Luckily we can ignore it if there is no limit/offset.</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Undef</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span>
                <span class="s2">&quot;__contains__() does not yet support set &quot;</span>
                <span class="s2">&quot;expressions that combine ORDER BY with &quot;</span>
                <span class="s2">&quot;LIMIT/OFFSET&quot;</span><span class="p">)</span>
        <span class="n">subexprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">replace_columns</span><span class="p">(</span><span class="n">subexpr</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">subexpr</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">exprs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="nb">all</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">all</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">limit</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
            <span class="o">*</span><span class="n">subexprs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">FeatureError</span><span class="p">(</span>
            <span class="s2">&quot;__contains__() does not yet support </span><span class="si">%r</span><span class="s2"> expressions&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,))</span>


<span class="k">class</span> <span class="nc">AutoReload</span><span class="p">(</span><span class="n">LazyValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A marker for reloading a single value.</span>

<span class="sd">    Often this will be used to specify that a specific attribute</span>
<span class="sd">    should be loaded from the database on the next access, like so::</span>

<span class="sd">        storm_object.property = AutoReload</span>

<span class="sd">    On the next access to C{storm_object.property}, the value will be</span>
<span class="sd">    loaded from the database.</span>

<span class="sd">    It is also often used as a default value for a property::</span>

<span class="sd">        class Person(object):</span>
<span class="sd">            __storm_table__ = &quot;person&quot;</span>
<span class="sd">            id = Int(allow_none=False, default=AutoReload)</span>

<span class="sd">        person = store.add(Person)</span>
<span class="sd">        person.id # gets the attribute from the database.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="n">AutoReload</span> <span class="o">=</span> <span class="n">AutoReload</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Gustavo Niemeyer.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>